name: Genera Sitemap

on:
  # Esegui ogni giorno alle 2:00 UTC (4:00 in Italia)
  schedule:
    - cron: '0 2 * * *'
  
  # Consente di eseguirlo manualmente dalla UI di GitHub
  workflow_dispatch:

jobs:
  generate:
    name: Genera e pubblica sitemap
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Installa dipendenze
        run: npm ci
      
      - name: Genera sitemap
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          SITEMAP_PATH: './public/sitemap.xml'
        run: |
          echo "Inizia generazione sitemap..."
          node -e "
          const { createClient } = require('@supabase/supabase-js');
          const fs = require('fs');
          
          async function generateSitemap() {
            console.log('üîÑ Avvio generazione sitemap...');
            
            try {
              // Parametri di base
              const SITEMAP_PATH = './public/sitemap.xml';
              const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://mastroianni.app';
              const supabaseUrl = process.env.SUPABASE_URL;
              const supabaseKey = process.env.SUPABASE_KEY;
              
              console.log(\`üåê URL base: \${baseUrl}\`);
              
              // Verifica variabili
              if (!supabaseUrl || !supabaseKey) {
                throw new Error('Mancano le variabili Supabase URL o KEY');
              }
              
              // Crea client Supabase
              const supabase = createClient(supabaseUrl, supabaseKey);
              
              // Recupera conteggio totale
              const { count: totalCount, error: countError } = await supabase
                .from('generated_pages')
                .select('*', { count: 'exact', head: true });
              
              if (countError) {
                throw new Error(\`Errore conteggio: \${countError.message}\`);
              }
              
              console.log(\`üî¢ Totale record nel DB: \${totalCount || 0}\`);
              
              // Funzione per recuperare tutti i record con paginazione
              async function fetchAllByType(type) {
                console.log(\`üîÑ Recupero completo dei record di tipo '\${type}'...\`);
                const batchSize = 1000;
                let allRecords = [];
                let startIndex = 0;
                let hasMore = true;
                
                try {
                  while (hasMore) {
                    console.log(\`  ‚è≥ Batch \${startIndex}-\${startIndex + batchSize - 1}...\`);
                    const { data, error } = await supabase
                      .from('generated_pages')
                      .select('slug')
                      .eq('page_type', type)
                      .range(startIndex, startIndex + batchSize - 1);
                      
                    if (error) {
                      console.error(\`  ‚ö†Ô∏è Errore recupero batch: \${error.message}\`);
                      break;
                    }
                    
                    const batchCount = data?.length || 0;
                    allRecords = allRecords.concat(data || []);
                    
                    console.log(\`  ‚úÖ Recuperati \${batchCount} record\`);
                    
                    if (batchCount < batchSize) {
                      hasMore = false;
                    } else {
                      startIndex += batchSize;
                    }
                  }
                  
                  console.log(\`‚úÖ Recupero completato: \${allRecords.length} record totali di tipo '\${type}'\`);
                  return allRecords;
                } catch (error) {
                  console.error(\`‚ùå Errore durante il recupero dei record di tipo '\${type}': \${error.message}\`);
                  return [];
                }
              }
              
              // Recupera film con paginazione
              console.log('üîÑ Recupero film...');
              const filmPages = await fetchAllByType('film');
              
              // Recupera serie con paginazione
              console.log('üîÑ Recupero serie...');
              const seriePages = await fetchAllByType('serie');
              
              // Recupera attori e altri tipi di persone
              console.log('üîÑ Recupero persone e altri tipi...');
              let crewPages = [];
              try {
                const { data, error } = await supabase
                  .from('generated_pages')
                  .select('slug, page_type')
                  .not('page_type', 'in', '("film","serie")');
                
                if (error) {
                  console.error(\`‚ùå Errore query persone: \${error.message}\`);
                } else {
                  crewPages = data || [];
                }
              } catch (error) {
                console.error(\`‚ùå Errore durante il recupero delle persone: \${error.message}\`);
              }
              
              // Filtra slug vuoti
              const filmSlugs = (filmPages || [])
                .map(page => page.slug)
                .filter(slug => slug && slug.trim() !== '');
                
              const serieSlugs = (seriePages || [])
                .map(page => page.slug)
                .filter(slug => slug && slug.trim() !== '');
              
              // Filtra e raggruppa le persone per tipo
              const personSlugs = {};
              (crewPages || []).forEach(page => {
                if (page.slug && page.slug.trim() !== '') {
                  const tipo = page.page_type || 'person';
                  if (!personSlugs[tipo]) personSlugs[tipo] = [];
                  personSlugs[tipo].push(page.slug);
                }
              });
              
              // Calcola conteggio totale di persone
              const totalPersons = Object.values(personSlugs).reduce((sum, slugs) => sum + slugs.length, 0);
              
              console.log(\`üé¨ Film validi: \${filmSlugs.length}, üì∫ Serie valide: \${serieSlugs.length}, üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Persone valide: \${totalPersons}\`);
              
              // Log dettagliato persone per tipo
              Object.entries(personSlugs).forEach(([tipo, slugs]) => {
                console.log(\`    - \${tipo}: \${slugs.length} pagine\`);
              });
              
              // Funzione per determinare il percorso corretto per ogni tipo di persona
              const getPersonPath = (tipo, slug) => {
                switch (tipo.toLowerCase()) {
                  case 'actor':
                  case 'attore':
                    return \`/attore/\${slug}\`;
                  case 'director':
                  case 'regista':
                    return \`/regista/\${slug}\`;
                  case 'cast':
                    return \`/cast/\${slug}\`;
                  case 'crew':
                    return \`/crew/\${slug}\`;
                  case 'person':
                  default:
                    return \`/person/\${slug}\`;
                }
              };
              
              // Rotte statiche
              const staticRoutes = ['', '/search', '/login', '/about'];
              const totalUrls = staticRoutes.length + filmSlugs.length + serieSlugs.length + totalPersons;
              
              console.log(\`üìä Totale URL sitemap: \${totalUrls}\`);
              
              // Genera sitemap
              const xml = \`<?xml version="1.0" encoding="UTF-8"?>
          <!-- Generata il: \${new Date().toISOString()} con \${totalUrls} URL -->
          <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" count="\${totalUrls}">
            \${staticRoutes.map(route => \`
              <url>
                <loc>\${baseUrl}\${route}</loc>
                <changefreq>weekly</changefreq>
                <priority>\${route === '' ? '1.0' : '0.8'}</priority>
              </url>
            \`).join('')}
            
            \${filmSlugs.map(slug => \`
              <url>
                <loc>\${baseUrl}/film/\${slug}</loc>
                <changefreq>monthly</changefreq>
                <priority>0.7</priority>
              </url>
            \`).join('')}
            
            \${serieSlugs.map(slug => \`
              <url>
                <loc>\${baseUrl}/serie/\${slug}</loc>
                <changefreq>monthly</changefreq>
                <priority>0.7</priority>
              </url>
            \`).join('')}
            
            \${Object.entries(personSlugs).flatMap(([tipo, slugs]) => 
              slugs.map(slug => \`
              <url>
                <loc>\${baseUrl}\${getPersonPath(tipo, slug)}</loc>
                <changefreq>monthly</changefreq>
                <priority>0.6</priority>
              </url>
            \`)).join('')}
          </urlset>\`;
              
              try {
                // Salva sitemap
                fs.writeFileSync(SITEMAP_PATH, xml);
                console.log(\`‚úÖ Sitemap generata con successo in \${SITEMAP_PATH}\`);
              } catch (fileError) {
                throw new Error(\`Errore durante la scrittura del file: \${fileError.message}\`);
              }
              
              // Aggiorna statistiche
              try {
                const { error: statsError } = await supabase
                  .from('sitemap_stats')
                  .upsert([{
                    id: 1,
                    last_generation: new Date().toISOString(),
                    urls_count: totalUrls,
                    film_count: filmSlugs.length,
                    serie_count: serieSlugs.length,
                    person_count: totalPersons,
                    is_error: false,
                    error_message: null
                  }]);
                  
                if (statsError) {
                  console.error(\`‚ö†Ô∏è Errore aggiornamento statistiche: \${statsError.message}\`);
                } else {
                  console.log('üìä Statistiche aggiornate con successo');
                }
              } catch (statsError) {
                console.error(\`‚ö†Ô∏è Errore durante aggiornamento statistiche: \${statsError.message}\`);
              }
              
              return {
                success: true,
                message: \`Sitemap generata con successo (\${totalUrls} URL)\`,
                timestamp: new Date().toISOString(),
                urlCount: totalUrls,
                filmCount: filmSlugs.length,
                serieCount: serieSlugs.length,
                personCount: totalPersons
              };
            } catch (error) {
              console.error(\`‚ùå ERRORE: \${error.message}\`);
              
              // Tenta di aggiornare le statistiche con l'errore
              try {
                await supabase
                  .from('sitemap_stats')
                  .upsert([{
                    id: 1,
                    last_generation: new Date().toISOString(),
                    urls_count: 0,
                    film_count: 0,
                    serie_count: 0,
                    person_count: 0,
                    is_error: true,
                    error_message: error.message
                  }]);
              } catch (statsError) {
                console.error(\`‚ö†Ô∏è Errore durante aggiornamento statistiche di errore: \${statsError.message}\`);
              }
              
              return { success: false, error: error.message };
            }
          }
          
          // Esegui la generazione
          (async () => {
            const result = await generateSitemap();
            console.log('üìã Risultato:', JSON.stringify(result, null, 2));
            if (!result.success) process.exit(1);
          })();
          "
      
      - name: Commit e push sitemap
        run: |
          git config --global user.name 'GitHub Action Bot'
          git config --global user.email 'action@github.com'
          git add public/sitemap.xml
          git commit -m "Aggiorna sitemap.xml [skip ci]" || echo "Nessuna modifica da committare"
          git push
