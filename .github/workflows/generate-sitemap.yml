name: Generate Static Sitemap

on:
  # Esecuzione manuale dal dashboard di GitHub
  workflow_dispatch:
  
  # Esecuzione automatica ogni notte
  schedule:
    # Esegue ogni notte alle 2:00 UTC (4:00 CEST) - La sintassi √® "minuti ore * * giorno(0-6, dove 0=domenica)"
    - cron: '0 2 * * *'
  
  # Esegui anche dopo ogni push sul main (opzionale)
  push:
    branches:
      - main
    paths:
      # Esegui solo se sono stati modificati file rilevanti per la sitemap
      - 'scripts/generate-static-sitemap.js'
      - '.github/workflows/generate-sitemap.yml'
      - 'public/sitemap.xml'

jobs:
  generate-sitemap:
    runs-on: ubuntu-latest
    
    # Impedisci l'esecuzione se il repository √® forkato (sicurezza)
    if: github.repository == 'napieracademy/mst'

    # Richiedi permessi espliciti per il token
    permissions:
      contents: write

    env:
      # Definisci direttamente le variabili d'ambiente necessarie
      NEXT_PUBLIC_SITE_URL: 'https://mastroianni.app'
      # Utilizza le credenziali reali di Supabase (sono credenziali pubbliche, possono essere mostrate)
      NEXT_PUBLIC_SUPABASE_URL: 'https://gbynhfiqlacmlwpjcxmp.supabase.co'
      # L'API key anonima √® pubblica, quindi pu√≤ essere inclusa direttamente qui
      NEXT_PUBLIC_SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdieW5oZmlxbGFjbWx3cGpjeG1wIiwicm9sZSI6ImFub24iLCJpYXQiOjE2MzU1NDA4NjYsImV4cCI6MTk1MTExNjg2Nn0.M02gdvw2hHI8eyKuHFWV2F5bqXKFt2Zfwd3GMR1dKr0'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Ottieni pi√π storia per permettere il rebase
          fetch-depth: 0

      - name: Setup Node.js 20.x
        uses: actions/setup-node@v3
        with:
          node-version: 20.x
          cache: 'npm'

      # DEBUG - Mostra le variabili d'ambiente (mascherate per sicurezza)
      - name: Debug - Environment Variables
        run: |
          echo "NEXT_PUBLIC_SITE_URL exists: ${{ env.NEXT_PUBLIC_SITE_URL != '' }}"
          echo "NEXT_PUBLIC_SUPABASE_URL exists: ${{ env.NEXT_PUBLIC_SUPABASE_URL != '' }}"
          echo "NEXT_PUBLIC_SUPABASE_ANON_KEY exists: ${{ env.NEXT_PUBLIC_SUPABASE_ANON_KEY != '' }}"
          # Verifica lunghezza diretta in bash
          if [ -n "$NEXT_PUBLIC_SUPABASE_ANON_KEY" ]; then
            echo "NEXT_PUBLIC_SUPABASE_ANON_KEY length: $(echo $NEXT_PUBLIC_SUPABASE_ANON_KEY | wc -c)"
          fi

      - name: Install dependencies
        run: npm install

      # DEBUG - Verifica connessione a Supabase con uno script dedicato
      - name: Test Supabase connection
        run: |
          cat > test-supabase.js << 'EOF'
          // Script per testare la connessione a Supabase
          import { createClient } from '@supabase/supabase-js';

          // Usa direttamente le variabili d'ambiente qui
          const SUPABASE_URL = 'https://gbynhfiqlacmlwpjcxmp.supabase.co';
          const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdieW5oZmlxbGFjbWx3cGpjeG1wIiwicm9sZSI6ImFub24iLCJpYXQiOjE2MzU1NDA4NjYsImV4cCI6MTk1MTExNjg2Nn0.M02gdvw2hHI8eyKuHFWV2F5bqXKFt2Zfwd3GMR1dKr0';

          console.log('Iniziando test connessione Supabase...');
          console.log(`URL Supabase: ${SUPABASE_URL}`);
          console.log(`Lunghezza chiave: ${SUPABASE_KEY.length}`);

          const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

          async function testConnection() {
            try {
              console.log('Tentativo di connessione a Supabase...');
              const { count, error } = await supabase
                .from('contents')
                .select('*', { count: 'exact', head: true });
              
              if (error) {
                throw error;
              }
              
              console.log(`‚úÖ Connessione riuscita! Conteggio record: ${count}`);
              return true;
            } catch (error) {
              console.error('‚ùå Errore di connessione:', error.message);
              console.error('Stack traccia:', error.stack);
              return false;
            }
          }

          testConnection()
            .then(result => {
              if (!result) {
                console.error('‚ùå Test di connessione fallito');
                process.exit(1);
              }
            })
            .catch(err => {
              console.error('‚ùå Errore inaspettato:', err);
              process.exit(1);
            });
          EOF
          
          echo "Esecuzione test di connessione a Supabase..."
          node test-supabase.js

      # Genera la sitemap usando hardcoded values, senza dipendere dalle variabili d'ambiente
      - name: Generate static sitemap
        run: |
          cat > direct-sitemap-gen.js << 'EOF'
          // Script per generare la sitemap senza dipendere da ENV variabili
          import fs from 'fs';
          import path from 'path';
          import { createClient } from '@supabase/supabase-js';

          const SITE_URL = 'https://mastroianni.app';
          const SUPABASE_URL = 'https://gbynhfiqlacmlwpjcxmp.supabase.co';
          const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdieW5oZmlxbGFjbWx3cGpjeG1wIiwicm9sZSI6ImFub24iLCJpYXQiOjE2MzU1NDA4NjYsImV4cCI6MTk1MTExNjg2Nn0.M02gdvw2hHI8eyKuHFWV2F5bqXKFt2Zfwd3GMR1dKr0';

          console.log('Generazione sitemap.xml statica in corso...');
          console.log(`URL sito: ${SITE_URL}`);

          async function generateSitemap() {
            try {
              // Creazione client Supabase
              console.log(`Creazione client Supabase con URL: ${SUPABASE_URL}`);
              const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
              
              // Recupero conteggio totale
              console.log('SITEMAP DIRECT: Recupero tutti i record dal database in modo diretto...');
              const { count, error: countError } = await supabase
                .from('contents')
                .select('*', { count: 'exact', head: true });
                
              if (countError) throw countError;
              
              console.log(`SITEMAP DIRECT: Trovati ${count} record totali nel database`);
              
              // Recupero in pagine da 1000 record
              const pageSize = 1000;
              const totalPages = Math.ceil(count / pageSize);
              console.log(`SITEMAP DIRECT: Iniziando recupero in ${totalPages} pagine (${pageSize} record per pagina)`);
              
              let allContents = [];
              
              for (let page = 0; page < totalPages; page++) {
                const from = page * pageSize;
                const to = from + pageSize - 1;
                console.log(`SITEMAP DIRECT: Recupero pagina ${page+1}/${totalPages} (record ${from} - ${to})`);
                
                const { data, error } = await supabase
                  .from('contents')
                  .select('*')
                  .range(from, to);
                  
                if (error) throw error;
                
                console.log(`SITEMAP DIRECT: Recuperati ${data.length} record nella pagina ${page+1}`);
                allContents = [...allContents, ...data];
              }
              
              console.log(`SITEMAP DIRECT: Totale record recuperati: ${allContents.length} di ${count} attesi`);
              
              // Filtro per tipo
              const films = allContents.filter(item => item.type === 'movie');
              const series = allContents.filter(item => item.type === 'tv');
              
              console.log(`SITEMAP DIRECT: Record film: ${films.length}, serie: ${series.length}`);
              
              // Genera XML
              let sitemap = `<?xml version="1.0" encoding="UTF-8"?>
    <!-- Generata il: ${new Date().toISOString()} con ${films.length + series.length + 4} URL -->
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" count="${films.length + series.length + 4}">
      
        <url>
            <loc>${SITE_URL}/</loc>
            <changefreq>daily</changefreq>
            <priority>1.0</priority>
        </url>
        <url>
            <loc>${SITE_URL}/film</loc>
            <changefreq>daily</changefreq>
            <priority>0.9</priority>
        </url>
        <url>
            <loc>${SITE_URL}/serie</loc>
            <changefreq>daily</changefreq>
            <priority>0.9</priority>
        </url>
        <url>
            <loc>${SITE_URL}/search</loc>
            <changefreq>weekly</changefreq>
            <priority>0.8</priority>
        </url>`;
              
              // Aggiungi film
              films.forEach(film => {
                const slug = film.slug || `${film.id}`;
                sitemap += `
        <url>
            <loc>${SITE_URL}/film/${slug}</loc>
            <changefreq>weekly</changefreq>
            <priority>0.8</priority>
        </url>`;
              });
              
              // Aggiungi serie
              series.forEach(serie => {
                const slug = serie.slug || `${serie.id}`;
                sitemap += `
        <url>
            <loc>${SITE_URL}/serie/${slug}</loc>
            <changefreq>weekly</changefreq>
            <priority>0.8</priority>
        </url>`;
              });
              
              sitemap += `
    </urlset>`;
              
              // Assicurati che la directory public esista
              if (!fs.existsSync('public')) {
                fs.mkdirSync('public', { recursive: true });
              }
              
              // Scrivi il file
              fs.writeFileSync('public/sitemap.xml', sitemap);
              
              const fileSize = (Buffer.byteLength(sitemap) / 1024).toFixed(0);
              console.log(`SITEMAP DIRECT: File sitemap.xml generato e salvato in public/sitemap.xml`);
              console.log(`SITEMAP DIRECT: Dimensione file: ${fileSize} KB`);
              console.log(`SITEMAP DIRECT: URL totali: ${films.length + series.length + 4}`);
              console.log('‚úÖ Generazione sitemap statica completata');
              
              return true;
            } catch (error) {
              console.error('‚ùå Errore durante la generazione della sitemap:', error);
              console.error('Stack traccia:', error.stack);
              
              // Genera una sitemap di fallback minima
              console.log('üî∂ Generazione sitemap di fallback...');
              const fallbackSitemap = `<?xml version="1.0" encoding="UTF-8"?>
    <!-- Sitemap di fallback generata il: ${new Date().toISOString()} -->
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" count="4">
        <url>
            <loc>${SITE_URL}/</loc>
            <changefreq>daily</changefreq>
            <priority>1.0</priority>
        </url>
        <url>
            <loc>${SITE_URL}/film</loc>
            <changefreq>daily</changefreq>
            <priority>0.9</priority>
        </url>
        <url>
            <loc>${SITE_URL}/serie</loc>
            <changefreq>daily</changefreq>
            <priority>0.9</priority>
        </url>
        <url>
            <loc>${SITE_URL}/search</loc>
            <changefreq>weekly</changefreq>
            <priority>0.8</priority>
        </url>
    </urlset>`;
              
              if (!fs.existsSync('public')) {
                fs.mkdirSync('public', { recursive: true });
              }
              
              fs.writeFileSync('public/sitemap.xml', fallbackSitemap);
              console.log('‚úÖ Generazione sitemap di fallback completata');
              
              return false;
            }
          }

          generateSitemap();
          EOF
          
          mkdir -p public
          node direct-sitemap-gen.js
          ls -la public/sitemap.xml
          echo "Sitemap size: $(du -h public/sitemap.xml | cut -f1)"
          # Verifica conteggio URL
          URL_COUNT=$(grep -o "<url>" public/sitemap.xml | wc -l)
          echo "URL count: $URL_COUNT"
          # Salva il conteggio come variabile di output
          echo "URL_COUNT=$URL_COUNT" >> $GITHUB_ENV

      # Verifica il file generato
      - name: Verify generated sitemap
        run: |
          if [ ! -f "public/sitemap.xml" ]; then
            echo "Error: sitemap.xml was not generated!"
            exit 1
          fi
          if [ ! -s "public/sitemap.xml" ]; then
            echo "Error: sitemap.xml is empty!"
            exit 1
          fi
          echo "Sitemap generated successfully"
          head -n 10 public/sitemap.xml
          # Assicura che la sitemap contenga almeno 1000 URL (se in modalit√† fallback ne ha solo 24)
          if [ "${{ env.URL_COUNT }}" -lt 1000 ]; then
            echo "Warning: Sitemap contains only ${{ env.URL_COUNT }} URLs. Expected at least 1000."
            echo "This indicates a potential connection issue with the database."
            # Non considerarlo un errore, ma solo un avviso
          else
            echo "Sitemap contains ${{ env.URL_COUNT }} URLs, which looks correct!"
          fi

      # Commit la sitemap generata usando un'action specifica
      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Aggiorna sitemap.xml [skip ci]"
          commit_options: "--no-verify"
          file_pattern: "public/sitemap.xml"
          commit_user_name: GitHub Action
          commit_user_email: actions@github.com
          commit_author: GitHub Action <actions@github.com>
          status_options: "--untracked-files=no"
          add_options: "--force"
          skip_dirty_check: false # Verifica se ci sono modifiche
          commit_body: |
            Generato automaticamente dall'azione GitHub
            
            Conteggio URL: ${{ env.URL_COUNT }}
            Dimensione file: $(du -h public/sitemap.xml | cut -f1) 